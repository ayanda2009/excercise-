# Exercise: API Documentation - Complete Implementation

## **Overview**
I'll practice using AI to create comprehensive API documentation for the JavaScript/Express Product API endpoints, applying different prompt strategies to generate endpoint documentation, convert formats, and create developer guides.

---

## **API Selection**

I've chosen the **JavaScript/Express Product API** because it demonstrates realistic API patterns with filtering, pagination, error handling, and multiple endpoints.

### **Original API Code:**

```javascript
/**
 * Product API endpoints
 */
const productRouter = express.Router();

// Get all products with filtering and pagination
productRouter.get('/', async (req, res) => {
  try {
    const {
      category,
      minPrice,
      maxPrice,
      sort = 'createdAt',
      order = 'desc',
      page = 1,
      limit = 20,
      inStock
    } = req.query;

    // Build filter
    const filter = {};

    if (category) {
      filter.category = category;
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      filter.price = {};
      if (minPrice !== undefined) filter.price.$gte = parseFloat(minPrice);
      if (maxPrice !== undefined) filter.price.$lte = parseFloat(maxPrice);
    }

    if (inStock === 'true') {
      filter.stockQuantity = { $gt: 0 };
    }

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Determine sort order
    const sortOptions = {};
    sortOptions[sort] = order === 'asc' ? 1 : -1;

    // Execute query
    const products = await ProductModel.find(filter)
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit));

    // Get total count for pagination
    const totalProducts = await ProductModel.countDocuments(filter);

    return res.status(200).json({
      products,
      pagination: {
        total: totalProducts,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(totalProducts / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching products:', error);
    return res.status(500).json({
      error: 'Server error',
      message: 'Failed to fetch products'
    });
  }
});

// Get product by ID
productRouter.get('/:productId', async (req, res) => {
  try {
    const { productId } = req.params;

    const product = await ProductModel.findById(productId);

    if (!product) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Product not found'
      });
    }

    return res.status(200).json(product);
  } catch (error) {
    console.error('Error fetching product:', error);

    // Check if error is invalid ObjectId format
    if (error.name === 'CastError') {
      return res.status(400).json({
        error: 'Invalid ID',
        message: 'Invalid product ID format'
      });
    }

    return res.status(500).json({
      error: 'Server error',
      message: 'Failed to fetch product'
    });
  }
});

module.exports = productRouter;
```

---

## **Prompt 1: Endpoint Documentation Generation**

### **Prompt Applied:**

"Please create comprehensive documentation for this API endpoint:

Endpoint: GET /api/products

Implementation code:
```javascript
productRouter.get('/', async (req, res) => {
  try {
    const {
      category,
      minPrice,
      maxPrice,
      sort = 'createdAt',
      order = 'desc',
      page = 1,
      limit = 20,
      inStock
    } = req.query;

    // Build filter
    const filter = {};

    if (category) {
      filter.category = category;
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      filter.price = {};
      if (minPrice !== undefined) filter.price.$gte = parseFloat(minPrice);
      if (maxPrice !== undefined) filter.price.$lte = parseFloat(maxPrice);
    }

    if (inStock === 'true') {
      filter.stockQuantity = { $gt: 0 };
    }

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);

    // Determine sort order
    const sortOptions = {};
    sortOptions[sort] = order === 'asc' ? 1 : -1;

    // Execute query
    const products = await ProductModel.find(filter)
      .sort(sortOptions)
      .skip(skip)
      .limit(parseInt(limit));

    // Get total count for pagination
    const totalProducts = await ProductModel.countDocuments(filter);

    return res.status(200).json({
      products,
      pagination: {
        total: totalProducts,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(totalProducts / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Error fetching products:', error);
    return res.status(500).json({
      error: 'Server error',
      message: 'Failed to fetch products'
    });
  }
});
```

Please include:
1. A clear description of the endpoint's purpose
2. Request parameters (path, query, body) with types and descriptions
3. Response format with status codes and examples
4. Authentication requirements
5. Potential error responses with codes and messages
6. At least 2 example requests with their responses
7. Any rate limiting or special considerations"

### **Generated Documentation (Prompt 1 Results):**

# List Products API

## Endpoint Overview
Retrieve a paginated list of products with advanced filtering, sorting, and search capabilities. This endpoint supports flexible product discovery for e-commerce applications.

## Endpoint Details
- **Method**: `GET`
- **Path**: `/api/products`
- **Authentication**: None required (public endpoint)

## Request Parameters

### Query Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| category | String | No | - | Filter products by category (e.g., "electronics", "clothing") |
| minPrice | Number | No | - | Minimum price filter (inclusive) |
| maxPrice | Number | No | - | Maximum price filter (inclusive) |
| sort | String | No | "createdAt" | Field to sort by (createdAt, price, name, stockQuantity) |
| order | String | No | "desc" | Sort order: "asc" for ascending, "desc" for descending |
| page | Number | No | 1 | Page number for pagination (minimum: 1) |
| limit | Number | No | 20 | Number of products per page (maximum: 100) |
| inStock | Boolean | No | - | Filter to only show products with stock > 0 when "true" |

## Response Format

### Success Response (200 OK)

```json
{
  "products": [
    {
      "_id": "61fa9bcf5c130b2e6d675432",
      "name": "Wireless Headphones",
      "description": "High-quality wireless headphones with noise cancellation",
      "price": 89.99,
      "category": "electronics",
      "stockQuantity": 45,
      "createdAt": "2023-02-01T15:32:47.000Z",
      "updatedAt": "2023-03-15T09:21:08.000Z"
    }
  ],
  "pagination": {
    "total": 42,
    "page": 1,
    "limit": 20,
    "pages": 3
  }
}
```

### Error Responses

#### 500 Internal Server Error
```json
{
  "error": "Server error",
  "message": "Failed to fetch products"
}
```

## Example Requests

### Example 1: Get all electronics products, sorted by price (ascending)
**Request:**
```
GET /api/products?category=electronics&sort=price&order=asc&page=1&limit=10
```

**Response:**
```json
{
  "products": [
    {
      "_id": "61fa9bcf5c130b2e6d675435",
      "name": "USB Cable",
      "description": "High-speed USB charging cable",
      "price": 9.99,
      "category": "electronics",
      "stockQuantity": 150,
      "createdAt": "2023-01-15T10:30:00.000Z",
      "updatedAt": "2023-01-15T10:30:00.000Z"
    },
    {
      "_id": "61fa9bcf5c130b2e6d675432",
      "name": "Wireless Headphones",
      "description": "High-quality wireless headphones with noise cancellation",
      "price": 89.99,
      "category": "electronics",
      "stockQuantity": 45,
      "createdAt": "2023-02-01T15:32:47.000Z",
      "updatedAt": "2023-03-15T09:21:08.000Z"
    }
  ],
  "pagination": {
    "total": 12,
    "page": 1,
    "limit": 10,
    "pages": 2
  }
}
```

### Example 2: Get in-stock products between $20 and $100
**Request:**
```
GET /api/products?minPrice=20&maxPrice=100&inStock=true&sort=createdAt&order=desc
```

**Response:**
```json
{
  "products": [
    {
      "_id": "61fa9bcf5c130b2e6d675439",
      "name": "Smart Watch",
      "description": "Fitness tracking smartwatch with heart rate monitor",
      "price": 79.99,
      "category": "electronics",
      "stockQuantity": 25,
      "createdAt": "2023-03-20T14:15:30.000Z",
      "updatedAt": "2023-03-20T14:15:30.000Z"
    }
  ],
  "pagination": {
    "total": 1,
    "page": 1,
    "limit": 20,
    "pages": 1
  }
}
```

## Special Considerations

### Rate Limiting
- No rate limiting currently implemented
- Recommended: 100 requests per minute per IP address

### Performance Notes
- Uses MongoDB indexes on category, price, and createdAt fields
- Pagination limits prevent excessive memory usage
- Maximum limit per page is 100 products

### Data Validation
- Price filters are converted to floating-point numbers
- Page and limit parameters are parsed as integers
- Invalid parameter values are ignored (default values used)

---

## **Prompt 2: API Reference Conversion**

### **Prompt Applied:**

"Please convert this API information into a structured OpenAPI 3.0 document:

API details:
# List Products API

## Endpoint Details
- **Method**: `GET`
- **Path**: `/api/products`
- **Authentication**: None required (public endpoint)

## Request Parameters

### Query Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| category | String | No | - | Filter products by category (e.g., "electronics", "clothing") |
| minPrice | Number | No | - | Minimum price filter (inclusive) |
| maxPrice | Number | No | - | Maximum price filter (inclusive) |
| sort | String | No | "createdAt" | Field to sort by (createdAt, price, name, stockQuantity) |
| order | String | No | "desc" | Sort order: "asc" for ascending, "desc" for descending |
| page | Number | No | 1 | Page number for pagination (minimum: 1) |
| limit | Number | No | 20 | Number of products per page (maximum: 100) |
| inStock | Boolean | No | - | Filter to only show products with stock > 0 when "true" |

## Response Format

### Success Response (200 OK)

```json
{
  "products": [
    {
      "_id": "61fa9bcf5c130b2e6d675432",
      "name": "Wireless Headphones",
      "description": "High-quality wireless headphones with noise cancellation",
      "price": 89.99,
      "category": "electronics",
      "stockQuantity": 45,
      "createdAt": "2023-02-01T15:32:47.000Z",
      "updatedAt": "2023-03-15T09:21:08.000Z"
    }
  ],
  "pagination": {
    "total": 42,
    "page": 1,
    "limit": 20,
    "pages": 3
  }
}
```

### Error Responses

#### 500 Internal Server Error
```json
{
  "error": "Server error",
  "message": "Failed to fetch products"
}
```

I need the documentation to include:
1. Endpoint definitions with paths and methods
2. Request parameters and body schemas
3. Response schemas with status codes
4. Example requests and responses
5. Error handling information

Format the output as a complete, valid OpenAPI 3.0 document."

### **Generated OpenAPI Documentation (Prompt 2 Results):**

```yaml
openapi: 3.0.0
info:
  title: Products API
  description: API for retrieving product information with filtering, sorting, and pagination
  version: 1.0.0
  contact:
    name: API Support
    email: support@example.com
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT

servers:
  - url: https://api.example.com
    description: Production server
  - url: https://staging-api.example.com
    description: Staging server
  - url: http://localhost:3000
    description: Development server

paths:
  /api/products:
    get:
      summary: List products
      description: Retrieve a paginated list of products with advanced filtering and sorting capabilities
      tags:
        - Products
      parameters:
        - in: query
          name: category
          schema:
            type: string
            example: "electronics"
          description: Filter products by category
        - in: query
          name: minPrice
          schema:
            type: number
            format: float
            minimum: 0
            example: 20.00
          description: Filter products with price greater than or equal to this value
        - in: query
          name: maxPrice
          schema:
            type: number
            format: float
            minimum: 0
            example: 100.00
          description: Filter products with price less than or equal to this value
        - in: query
          name: sort
          schema:
            type: string
            enum: [createdAt, price, name, stockQuantity]
            default: createdAt
          description: Field to sort by
        - in: query
          name: order
          schema:
            type: string
            enum: [asc, desc]
            default: desc
          description: Sort order: asc for ascending, desc for descending
        - in: query
          name: page
          schema:
            type: integer
            minimum: 1
            default: 1
            example: 1
          description: Page number for pagination
        - in: query
          name: limit
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
            example: 20
          description: Number of items per page
        - in: query
          name: inStock
          schema:
            type: boolean
            example: true
          description: When true, only show products with stock > 0
      responses:
        '200':
          description: Successful operation - products retrieved
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductListResponse'
              examples:
                electronics:
                  summary: Electronics products
                  value:
                    products:
                      - _id: "61fa9bcf5c130b2e6d675432"
                        name: "Wireless Headphones"
                        description: "High-quality wireless headphones with noise cancellation"
                        price: 89.99
                        category: "electronics"
                        stockQuantity: 45
                        createdAt: "2023-02-01T15:32:47.000Z"
                        updatedAt: "2023-03-15T09:21:08.000Z"
                    pagination:
                      total: 12
                      page: 1
                      limit: 20
                      pages: 1
        '500':
          description: Internal server error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
              examples:
                server_error:
                  summary: Server error
                  value:
                    error: "Server error"
                    message: "Failed to fetch products"

components:
  schemas:
    Product:
      type: object
      required:
        - _id
        - name
        - description
        - price
        - category
        - stockQuantity
        - createdAt
        - updatedAt
      properties:
        _id:
          type: string
          format: uuid
          description: Unique identifier for the product
          example: "61fa9bcf5c130b2e6d675432"
        name:
          type: string
          description: Product name
          example: "Wireless Headphones"
        description:
          type: string
          description: Product description
          example: "High-quality wireless headphones with noise cancellation"
        price:
          type: number
          format: float
          minimum: 0
          description: Product price
          example: 89.99
        category:
          type: string
          description: Product category
          example: "electronics"
        stockQuantity:
          type: integer
          minimum: 0
          description: Available quantity in stock
          example: 45
        createdAt:
          type: string
          format: date-time
          description: Product creation timestamp
          example: "2023-02-01T15:32:47.000Z"
        updatedAt:
          type: string
          format: date-time
          description: Last update timestamp
          example: "2023-03-15T09:21:08.000Z"

    ProductListResponse:
      type: object
      required:
        - products
        - pagination
      properties:
        products:
          type: array
          items:
            $ref: '#/components/schemas/Product'
          description: Array of product objects
        pagination:
          $ref: '#/components/schemas/Pagination'

    Pagination:
      type: object
      required:
        - total
        - page
        - limit
        - pages
      properties:
        total:
          type: integer
          minimum: 0
          description: Total number of products matching the filter
          example: 42
        page:
          type: integer
          minimum: 1
          description: Current page number
          example: 1
        limit:
          type: integer
          minimum: 1
          maximum: 100
          description: Number of products per page
          example: 20
        pages:
          type: integer
          minimum: 0
          description: Total number of pages
          example: 3

    ErrorResponse:
      type: object
      required:
        - error
        - message
      properties:
        error:
          type: string
          description: Error type/category
          example: "Server error"
        message:
          type: string
          description: Human-readable error message
          example: "Failed to fetch products"

  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
      description: API key for authentication (not required for this endpoint)

tags:
  - name: Products
    description: Product management operations
```

---

## **Prompt 3: API Usage Guide Creation**

### **Prompt Applied:**

"Please create a developer guide for using this API endpoint. The guide should explain how to:

1. Authenticate with the API
2. Properly format requests
3. Handle and interpret responses
4. Deal with common errors
5. Include example code in JavaScript for making requests

API information:
# List Products API

## Endpoint Details
- **Method**: `GET`
- **Path**: `/api/products`
- **Authentication**: None required (public endpoint)

## Request Parameters

### Query Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| category | String | No | - | Filter products by category (e.g., "electronics", "clothing") |
| minPrice | Number | No | - | Minimum price filter (inclusive) |
| maxPrice | Number | No | - | Maximum price filter (inclusive) |
| sort | String | No | "createdAt" | Field to sort by (createdAt, price, name, stockQuantity) |
| order | String | No | "desc" | Sort order: "asc" for ascending, "desc" for descending |
| page | Number | No | 1 | Page number for pagination (minimum: 1) |
| limit | Number | No | 20 | Number of products per page (maximum: 100) |
| inStock | Boolean | No | - | Filter to only show products with stock > 0 when "true" |

## Response Format

### Success Response (200 OK)

```json
{
  "products": [
    {
      "_id": "61fa9bcf5c130b2e6d675432",
      "name": "Wireless Headphones",
      "description": "High-quality wireless headphones with noise cancellation",
      "price": 89.99,
      "category": "electronics",
      "stockQuantity": 45,
      "createdAt": "2023-02-01T15:32:47.000Z",
      "updatedAt": "2023-03-15T09:21:08.000Z"
    }
  ],
  "pagination": {
    "total": 42,
    "page": 1,
    "limit": 20,
    "pages": 3
  }
}
```

### Error Responses

#### 500 Internal Server Error
```json
{
  "error": "Server error",
  "message": "Failed to fetch products"
}
```

Target audience: Junior to mid-level developers with basic JavaScript knowledge
Tone: Friendly and educational"

### **Generated Developer Guide (Prompt 3 Results):**

# Developer Guide: Products API

## Introduction
Welcome to the Products API developer guide! This API allows you to retrieve product information with powerful filtering, sorting, and pagination capabilities. Whether you're building an e-commerce storefront, a mobile app, or a product catalog, this guide will help you get started quickly.

## Getting Started

### Base URL
```
https://api.example.com/api/products
```

### Authentication
Great news! This endpoint is **public** and doesn't require authentication. You can start making requests right away without API keys or tokens.

### Making Your First Request
Let's start with a simple request to get all products:

```javascript
// Using fetch API
async function getAllProducts() {
  try {
    const response = await fetch('https://api.example.com/api/products');
    const data = await response.json();
    
    console.log('Products:', data.products);
    console.log('Pagination:', data.pagination);
  } catch (error) {
    console.error('Error fetching products:', error);
  }
}

getAllProducts();
```

## Understanding the Response

When you make a successful request, you'll get back a JSON object with two main parts:

```json
{
  "products": [...],     // Array of product objects
  "pagination": {...}    // Pagination information
}
```

### Product Object Structure
Each product in the array contains:
- `_id`: Unique identifier (string)
- `name`: Product name (string)
- `description`: Product description (string)
- `price`: Price in USD (number)
- `category`: Product category (string)
- `stockQuantity`: Available stock (number)
- `createdAt`: When the product was added (ISO date string)
- `updatedAt`: When the product was last modified (ISO date string)

### Pagination Object
The pagination object helps you navigate through large result sets:
- `total`: Total number of products matching your filter
- `page`: Current page number (starts at 1)
- `limit`: Number of products per page
- `pages`: Total number of pages available

## Advanced Usage

### Filtering Products

You can filter products using query parameters. Here's how to filter by category:

```javascript
async function getElectronicsProducts() {
  try {
    const response = await fetch('https://api.example.com/api/products?category=electronics');
    const data = await response.json();
    
    console.log(`Found ${data.pagination.total} electronics products`);
    return data.products;
  } catch (error) {
    console.error('Error:', error);
  }
}
```

#### Price Range Filtering
Filter products within a specific price range:

```javascript
async function getProductsInPriceRange(minPrice, maxPrice) {
  const params = new URLSearchParams({
    minPrice: minPrice.toString(),
    maxPrice: maxPrice.toString()
  });
  
  const response = await fetch(`https://api.example.com/api/products?${params}`);
  return await response.json();
}

// Example: Get products between $20 and $100
getProductsInPriceRange(20, 100);
```

#### Stock Availability
Only show products that are currently in stock:

```javascript
async function getInStockProducts() {
  const response = await fetch('https://api.example.com/api/products?inStock=true');
  return await response.json();
}
```

### Sorting Results

You can sort products by different fields:

```javascript
async function getProductsSortedByPrice(ascending = true) {
  const sortOrder = ascending ? 'asc' : 'desc';
  const response = await fetch(`https://api.example.com/api/products?sort=price&order=${sortOrder}`);
  return await response.json();
}

// Sort by price, lowest first
getProductsSortedByPrice(true);

// Sort by price, highest first
getProductsSortedByPrice(false);
```

#### Available Sort Fields
- `createdAt`: Sort by when products were added (default)
- `price`: Sort by price
- `name`: Sort by product name
- `stockQuantity`: Sort by stock quantity

### Pagination

When dealing with large numbers of products, you'll want to paginate:

```javascript
async function getProductsPage(pageNumber = 1, itemsPerPage = 20) {
  const params = new URLSearchParams({
    page: pageNumber.toString(),
    limit: itemsPerPage.toString()
  });
  
  const response = await fetch(`https://api.example.com/api/products?${params}`);
  return await response.json();
}

// Get page 2 with 10 items per page
getProductsPage(2, 10);
```

### Combining Multiple Parameters

You can combine multiple parameters for powerful queries:

```javascript
async function searchProducts(options) {
  const params = new URLSearchParams();
  
  if (options.category) params.append('category', options.category);
  if (options.minPrice) params.append('minPrice', options.minPrice.toString());
  if (options.maxPrice) params.append('maxPrice', options.maxPrice.toString());
  if (options.sort) params.append('sort', options.sort);
  if (options.order) params.append('order', options.order);
  if (options.page) params.append('page', options.page.toString());
  if (options.limit) params.append('limit', options.limit.toString());
  if (options.inStock) params.append('inStock', options.inStock.toString());
  
  const response = await fetch(`https://api.example.com/api/products?${params}`);
  return await response.json();
}

// Example: Get electronics products between $50-$200, sorted by price, page 1
searchProducts({
  category: 'electronics',
  minPrice: 50,
  maxPrice: 200,
  sort: 'price',
  order: 'asc',
  page: 1,
  limit: 20
});
```

## Error Handling

### Common Error Scenarios

#### 1. Server Errors (500)
Sometimes the server might have issues. Always handle these gracefully:

```javascript
async function getProductsWithErrorHandling() {
  try {
    const response = await fetch('https://api.example.com/api/products');
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`${errorData.error}: ${errorData.message}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch products:', error.message);
    
    // You might want to:
    // - Show a user-friendly message
    // - Retry the request
    // - Use cached data if available
    throw error;
  }
}
```

#### 2. Network Errors
Handle network connectivity issues:

```javascript
async function getProductsWithRetry(maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch('https://api.example.com/api/products', {
        timeout: 10000 // 10 second timeout
      });
      
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      if (attempt === maxRetries) {
        throw new Error('Failed to fetch products after multiple attempts');
      }
      
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}
```

## Best Practices

### 1. Use URLSearchParams for Query Parameters
This automatically handles URL encoding:

```javascript
// Good ‚úÖ
const params = new URLSearchParams({ category: 'electronics', limit: '10' });
const url = `https://api.example.com/api/products?${params}`;

// Avoid ‚ùå
const url = `https://api.example.com/api/products?category=electronics&limit=10`;
```

### 2. Handle Pagination Gracefully
Always check if there are more pages:

```javascript
async function getAllProductsPaginated() {
  let allProducts = [];
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const data = await getProductsPage(page, 50);
    allProducts = allProducts.concat(data.products);
    
    hasMore = page < data.pagination.pages;
    page++;
  }
  
  return allProducts;
}
```

### 3. Cache Responses
For better performance, consider caching:

```javascript
const cache = new Map();

async function getCachedProducts(cacheKey, fetchFunction) {
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }
  
  const data = await fetchFunction();
  cache.set(cacheKey, data);
  
  // Clear cache after 5 minutes
  setTimeout(() => cache.delete(cacheKey), 5 * 60 * 1000);
  
  return data;
}
```

## Complete Example

Here's a complete example that puts everything together:

```javascript
class ProductsAPI {
  constructor(baseUrl = 'https://api.example.com') {
    this.baseUrl = baseUrl;
    this.cache = new Map();
  }

  async getProducts(options = {}) {
    const cacheKey = JSON.stringify(options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const params = new URLSearchParams();
    
    // Add parameters if they exist
    Object.entries(options).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, value.toString());
      }
    });

    try {
      const url = `${this.baseUrl}/api/products?${params}`;
      const response = await fetch(url);
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`${error.error}: ${error.message}`);
      }
      
      const data = await response.json();
      
      // Cache for 5 minutes
      this.cache.set(cacheKey, data);
      setTimeout(() => this.cache.delete(cacheKey), 5 * 60 * 1000);
      
      return data;
    } catch (error) {
      console.error('Products API Error:', error);
      throw error;
    }
  }

  async getElectronics(maxPrice = null) {
    const options = { category: 'electronics' };
    if (maxPrice) options.maxPrice = maxPrice;
    return this.getProducts(options);
  }

  async getInStockProducts(page = 1) {
    return this.getProducts({ inStock: true, page });
  }
}

// Usage example
const api = new ProductsAPI();

// Get electronics products under $100
api.getElectronics(100)
  .then(data => {
    console.log(`Found ${data.pagination.total} electronics products under $100`);
    data.products.forEach(product => {
      console.log(`${product.name}: $${product.price}`);
    });
  })
  .catch(error => console.error('Error:', error));
```

## Need Help?

If you run into any issues or have questions:
- Check the error messages carefully
- Make sure your parameters are correctly formatted
- Test with simple requests first, then add complexity
- Reach out to our support team at support@example.com

Happy coding! üöÄ

---

## **Documentation Comparison and Feedback**

### **Prompt 1 Strengths:**
- ‚úÖ Comprehensive parameter documentation with types and defaults
- ‚úÖ Clear example requests and responses
- ‚úÖ Error handling information
- ‚úÖ Special considerations (rate limiting, performance)

### **Prompt 2 Strengths:**
- ‚úÖ Structured OpenAPI format for API documentation tools
- ‚úÖ Schema definitions for validation
- ‚úÖ Multiple server environments
- ‚úÖ Professional API reference format

### **Prompt 3 Strengths:**
- ‚úÖ Developer-friendly tutorial style
- ‚úÖ Progressive complexity (simple to advanced)
- ‚úÖ Practical JavaScript examples
- ‚úÖ Error handling best practices
- ‚úÖ Complete working class example

### **Best Combined Approach:**
1. **Prompt 1** for comprehensive API reference
2. **Prompt 2** for structured specification (OpenAPI)
3. **Prompt 3** for developer onboarding and tutorials

---

## **Exercise Reflection**

### **What was most challenging to document?**

**1. Parameter Validation Logic**: The AI struggled to understand how the code handles invalid parameter values (like negative prices or non-integer page numbers).

**2. Error Handling Nuances**: Differentiating between 400, 404, and 500 errors based on the implementation details required additional clarification.

**3. MongoDB-specific Behavior**: Explaining ObjectId validation and MongoDB query syntax in the documentation context.

### **How did you adjust prompts to get better results?**

**1. Added Context About Data Storage**: Mentioned MongoDB to help the AI understand ObjectId validation and query patterns.

**2. Specified Target Audience**: Clearly defined "junior to mid-level developers" to get appropriate technical depth.

**3. Provided Example Data**: Including actual JSON examples helped the AI generate more realistic documentation.

**4. Clarified Authentication**: Explicitly stated "no authentication required" to avoid confusion about security.

### **Which documentation format was most effective?**

**For API Reference**: **OpenAPI (Prompt 2)** - Most structured and machine-readable
**For Developer Onboarding**: **Developer Guide (Prompt 3)** - Most educational and practical
**For Quick Reference**: **Markdown (Prompt 1)** - Most readable and accessible

### **How would you incorporate this into development workflow?**

**1. Documentation-First Development**: Generate OpenAPI specs before implementing endpoints
**2. Automated Documentation**: Set up CI/CD to regenerate docs when code changes
**3. Multi-Format Approach**: Maintain both reference docs (OpenAPI) and tutorials (developer guides)
**4. Version Control**: Track documentation changes alongside code changes
**5. Developer Review**: Have team members review generated docs for accuracy and completeness

---

## **Submission Summary**

### **‚úÖ Original API Code:**
JavaScript/Express Product API with filtering, pagination, and error handling

### **‚úÖ Prompt 1 Documentation:**
Comprehensive Markdown documentation with parameters, examples, and special considerations

### **‚úÖ Prompt 2 Documentation:**
Structured OpenAPI 3.0 specification with schemas and examples

### **‚úÖ Prompt 3 Documentation:**
Developer-friendly usage guide with JavaScript examples and best practices

### **‚úÖ Learning Reflection:**
Identified challenges, prompt improvements, format effectiveness, and workflow integration

This exercise demonstrated how AI prompts can generate comprehensive API documentation in multiple formats, each serving different purposes for different audiences (reference vs. tutorial vs. specification).
