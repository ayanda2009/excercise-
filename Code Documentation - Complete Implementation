# Exercise: Code Documentation - Complete Implementation

## **Overview**
I'll practice using AI to generate comprehensive documentation for the Task Priority Sorting Algorithm, applying both prompt strategies to create thorough, developer-friendly documentation.

---

## **Code Selection**

I've chosen the **Task Priority Sorting Algorithm** because it's complex enough to benefit from detailed documentation, with multiple factors, edge cases, and business logic that need clear explanation.

### **Original Code to Document:**

```python
def calculate_task_score(task):
    """Calculate a priority score for a task based on multiple factors."""
    # Base priority weights
    priority_weights = {
        TaskPriority.LOW: 1,
        TaskPriority.MEDIUM: 2,
        TaskPriority.HIGH: 4,
        TaskPriority.URGENT: 6
    }

    # Calculate base score from priority
    score = priority_weights.get(task.priority, 0) * 10

    # Add due date factor (higher score for tasks due sooner)
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks
            score += 35
        elif days_until_due == 0:  # Due today
            score += 20
        elif days_until_due <= 2:  # Due in next 2 days
            score += 15
        elif days_until_due <= 7:  # Due in next week
            score += 10

    # Reduce score for tasks that are completed or in review
    if task.status == TaskStatus.DONE:
        score -= 50
    elif task.status == TaskStatus.REVIEW:
        score -= 15

    # Boost score for tasks with certain tags
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Boost score for recently updated tasks
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:
        score += 5

    return score

def sort_tasks_by_importance(tasks):
    """Sort tasks by calculated importance score (highest first)."""
    # Calculate scores once and sort by the score
    task_scores = [(calculate_task_score(task), task) for task in tasks]
    sorted_tasks = [task for _, task in sorted(task_scores, reverse=True)]
    return sorted_tasks

def get_top_priority_tasks(tasks, limit=5):
    """Return the top N priority tasks."""
    sorted_tasks = sort_tasks_by_importance(tasks)
    return sorted_tasks[:limit]
```

---

## **Prompt 1: Comprehensive Function Documentation**

### **Prompt Applied:**

"Please create comprehensive documentation for this function following Python docstring conventions:

```python
def calculate_task_score(task):
    """Calculate a priority score for a task based on multiple factors."""
    # Base priority weights
    priority_weights = {
        TaskPriority.LOW: 1,
        TaskPriority.MEDIUM: 2,
        TaskPriority.HIGH: 4,
        TaskPriority.URGENT: 6
    }

    # Calculate base score from priority
    score = priority_weights.get(task.priority, 0) * 10

    # Add due date factor (higher score for tasks due sooner)
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks
            score += 35
        elif days_until_due == 0:  # Due today
            score += 20
        elif days_until_due <= 2:  # Due in next 2 days
            score += 15
        elif days_until_due <= 7:  # Due in next week
            score += 10

    # Reduce score for tasks that are completed or in review
    if task.status == TaskStatus.DONE:
        score -= 50
    elif task.status == TaskStatus.REVIEW:
        score -= 15

    # Boost score for tasks with certain tags
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Boost score for recently updated tasks
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:
        score += 5

    return score

def sort_tasks_by_importance(tasks):
    """Sort tasks by calculated importance score (highest first)."""
    # Calculate scores once and sort by the score
    task_scores = [(calculate_task_score(task), task) for task in tasks]
    sorted_tasks = [task for _, task in sorted(task_scores, reverse=True)]
    return sorted_tasks

def get_top_priority_tasks(tasks, limit=5):
    """Return the top N priority tasks."""
    sorted_tasks = sort_tasks_by_importance(tasks)
    return sorted_tasks[:limit]
```

The documentation should include:
1. A clear description of what the function does
2. All parameters with types and descriptions
3. Return value with type and description
4. Any exceptions or errors that might be thrown
5. Example usage
6. Any important notes or edge cases developers should be aware of"

### **Generated Documentation (Prompt 1 Results):**

```python
def calculate_task_score(task):
    """
    Calculate a priority score for a task based on multiple weighted factors.
    
    This function implements a compensatory scoring model that evaluates tasks
    based on priority level, due date proximity, completion status, special tags,
    and recent activity. The resulting score can be used to sort tasks by
    importance, with higher scores indicating greater priority.
    
    Args:
        task (Task): A task object with the following required attributes:
            - priority (TaskPriority): The task's priority level (LOW, MEDIUM, HIGH, URGENT)
            - due_date (datetime, optional): Due date for the task, None if no due date
            - status (TaskStatus): Current status of the task (TODO, IN_PROGRESS, REVIEW, DONE)
            - tags (list): List of string tags associated with the task
            - updated_at (datetime): Timestamp of last task update
    
    Returns:
        int: A numerical priority score. Higher values indicate higher priority.
             Scores can be negative for completed tasks. Typical range: -40 to 103.
    
    Raises:
        AttributeError: If the task object is missing required attributes
        TypeError: If task attributes are of unexpected types
    
    Example:
        >>> from datetime import datetime, timedelta
        >>> task = Task("Test task", priority=TaskPriority.HIGH)
        >>> task.due_date = datetime.now() + timedelta(days=1)
        >>> task.status = TaskStatus.TODO
        >>> task.tags = ["urgent"]
        >>> task.updated_at = datetime.now()
        >>> score = calculate_task_score(task)
        >>> print(f"Task score: {score}")
        Task score: 63
    
    Notes:
        - Overdue tasks receive the highest time-based bonus (35 points)
        - Completed tasks receive a 50-point penalty, effectively removing them from priority lists
        - Tasks with special tags ("blocker", "critical", "urgent") receive an 8-point boost
        - Recently updated tasks (within 24 hours) receive a 5-point boost
        - The scoring system is designed to allow time-sensitive factors to override lower priority levels
    """
    # Base priority weights
    priority_weights = {
        TaskPriority.LOW: 1,
        TaskPriority.MEDIUM: 2,
        TaskPriority.HIGH: 4,
        TaskPriority.URGENT: 6
    }

    # Calculate base score from priority
    score = priority_weights.get(task.priority, 0) * 10

    # Add due date factor (higher score for tasks due sooner)
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks
            score += 35
        elif days_until_due == 0:  # Due today
            score += 20
        elif days_until_due <= 2:  # Due in next 2 days
            score += 15
        elif days_until_due <= 7:  # Due in next week
            score += 10

    # Reduce score for tasks that are completed or in review
    if task.status == TaskStatus.DONE:
        score -= 50
    elif task.status == TaskStatus.REVIEW:
        score -= 15

    # Boost score for tasks with certain tags
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Boost score for recently updated tasks
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:
        score += 5

    return score


def sort_tasks_by_importance(tasks):
    """
    Sort a list of tasks by their calculated importance scores in descending order.
    
    This function calculates priority scores for all tasks and returns them sorted
    from highest to lowest priority. The scoring is performed once per task to
    maintain efficiency during the sorting process.
    
    Args:
        tasks (list[Task]): A list of task objects to be sorted. Each task must
                           have the attributes required by calculate_task_score().
    
    Returns:
        list[Task]: A new list of tasks sorted by priority score in descending order
                   (highest priority first). The original list is not modified.
    
    Raises:
        TypeError: If tasks is not iterable or contains non-Task objects
        AttributeError: If any task is missing required attributes
    
    Example:
        >>> tasks = [task1, task2, task3]
        >>> sorted_tasks = sort_tasks_by_importance(tasks)
        >>> for i, task in enumerate(sorted_tasks):
        ...     print(f"{i+1}. {task.title} (Score: {calculate_task_score(task)})")
    
    Notes:
        - Time complexity: O(n log n) due to sorting
        - Space complexity: O(n) for storing task-score pairs
        - This function creates a new list and does not modify the original
        - Empty lists return an empty list
    """
    # Calculate scores once and sort by the score
    task_scores = [(calculate_task_score(task), task) for task in tasks]
    sorted_tasks = [task for _, task in sorted(task_scores, reverse=True)]
    return sorted_tasks


def get_top_priority_tasks(tasks, limit=5):
    """
    Return the top N highest priority tasks from a list.
    
    This function combines scoring and filtering to return the most important
    tasks based on the priority scoring algorithm. It's useful for dashboards,
    notifications, or focusing attention on the most critical items.
    
    Args:
        tasks (list[Task]): A list of task objects to evaluate
        limit (int, optional): Maximum number of tasks to return. Defaults to 5.
                              Must be a positive integer.
    
    Returns:
        list[Task]: A list containing up to 'limit' tasks sorted by priority
                   in descending order. Returns fewer tasks if the input list
                   contains fewer than 'limit' items.
    
    Raises:
        ValueError: If limit is less than 1
        TypeError: If tasks is not iterable or contains non-Task objects
    
    Example:
        >>> all_tasks = get_all_tasks()
        >>> top_3 = get_top_priority_tasks(all_tasks, limit=3)
        >>> print(f"Top 3 priorities:")
        >>> for i, task in enumerate(top_3, 1):
        ...     print(f"{i}. {task.title}")
    
    Notes:
        - If limit exceeds the number of available tasks, all tasks are returned
        - The returned tasks are already sorted by priority
        - This function is equivalent to: sort_tasks_by_importance(tasks)[:limit]
        - Performance is optimized for small limits relative to total task count
    """
    sorted_tasks = sort_tasks_by_importance(tasks)
    return sorted_tasks[:limit]
```

---

## **Prompt 2: Intent and Logic Explanation**

### **Prompt Applied:**

"I need help documenting the intent and logic behind this code. Please:

```python
def calculate_task_score(task):
    """Calculate a priority score for a task based on multiple factors."""
    # Base priority weights
    priority_weights = {
        TaskPriority.LOW: 1,
        TaskPriority.MEDIUM: 2,
        TaskPriority.HIGH: 4,
        TaskPriority.URGENT: 6
    }

    # Calculate base score from priority
    score = priority_weights.get(task.priority, 0) * 10

    # Add due date factor (higher score for tasks due sooner)
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks
            score += 35
        elif days_until_due == 0:  # Due today
            score += 20
        elif days_until_due <= 2:  # Due in next 2 days
            score += 15
        elif days_until_due <= 7:  # Due in next week
            score += 10

    # Reduce score for tasks that are completed or in review
    if task.status == TaskStatus.DONE:
        score -= 50
    elif task.status == TaskStatus.REVIEW:
        score -= 15

    # Boost score for tasks with certain tags
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Boost score for recently updated tasks
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:
        score += 5

    return score

def sort_tasks_by_importance(tasks):
    """Sort tasks by calculated importance score (highest first)."""
    # Calculate scores once and sort by the score
    task_scores = [(calculate_task_score(task), task) for task in tasks]
    sorted_tasks = [task for _, task in sorted(task_scores, reverse=True)]
    return sorted_tasks

def get_top_priority_tasks(tasks, limit=5):
    """Return the top N priority tasks."""
    sorted_tasks = sort_tasks_by_importance(tasks)
    return sorted_tasks[:limit]
```

1. Explain what this code is trying to accomplish at a high level
2. Break down the logic step-by-step
3. Identify any assumptions or edge cases in the implementation
4. Suggest inline comments for complex parts
5. Note any potential improvements while maintaining the original functionality"

### **Generated Insights (Prompt 2 Results):**

#### **1. High-Level Intent:**
This code implements a **sophisticated task prioritization system** that goes beyond simple priority levels. It's designed to help users focus on the most important tasks by considering multiple real-world factors: inherent importance, time sensitivity, work status, special circumstances, and activity levels.

#### **2. Step-by-Step Logic Breakdown:**

**calculate_task_score() Logic:**
```
Step 1: Establish baseline importance using priority levels (10-60 points)
Step 2: Add time-based urgency (0-35 points for due date proximity)
Step 3: Apply work status penalties (0-50 points reduction)
Step 4: Add special circumstance boosts (0-8 points for critical tags)
Step 5: Add activity maintenance boost (0-5 points for recent updates)
Step 6: Return final composite score
```

**sort_tasks_by_importance() Logic:**
```
Step 1: Create list of (score, task) tuples for all tasks
Step 2: Sort tuples by score in descending order
Step 3: Extract and return only the tasks in sorted order
```

**get_top_priority_tasks() Logic:**
```
Step 1: Sort all tasks by importance using sort_tasks_by_importance()
Step 2: Return first 'limit' tasks from sorted list
```

#### **3. Assumptions and Edge Cases:**

**Assumptions:**
- Task objects have all required attributes with correct types
- datetime.now() represents the current moment for all calculations
- Priority levels follow a hierarchical importance model
- Due dates are in the same timezone as the current time

**Edge Cases Handled:**
- Tasks without due dates (no time-based scoring applied)
- Unknown priority levels (default to 0 points)
- Empty task lists (return empty lists)
- Negative scores (completed high-priority tasks)
- Limit larger than available tasks (return all tasks)

**Potential Unhandled Edge Cases:**
- Tasks with due dates in the distant past (very overdue)
- Very large numbers of tags (performance impact)
- Concurrent task updates during scoring

#### **4. Suggested Inline Comments:**

```python
def calculate_task_score(task):
    """Calculate a priority score for a task based on multiple factors."""
    # Base priority weights - non-linear progression creates meaningful gaps
    priority_weights = {
        TaskPriority.LOW: 1,    # Baseline importance
        TaskPriority.MEDIUM: 2,  # 2x low priority
        TaskPriority.HIGH: 4,    # 4x low priority, 2x medium
        TaskPriority.URGENT: 6   # 6x low priority, 1.5x high
    }

    # Calculate base score from priority (multiplied by 10 for range)
    score = priority_weights.get(task.priority, 0) * 10

    # Time-based urgency: overdue > due today > due soon > due later
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks get highest urgency bonus
            score += 35
        elif days_until_due == 0:  # Due today - immediate attention needed
            score += 20
        elif days_until_due <= 2:  # Due this week - plan soon
            score += 15
        elif days_until_due <= 7:  # Due next week - upcoming priority
            score += 10

    # Status-based filtering: remove completed, reduce in-progress
    if task.status == TaskStatus.DONE:
        score -= 50  # Effectively removes from priority consideration
    elif task.status == TaskStatus.REVIEW:
        score -= 15  # Reduces priority but keeps visible

    # Special circumstances override normal priority calculations
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Activity maintenance: encourage recent task management
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:  # Updated within last 24 hours
        score += 5

    return score
```

#### **5. Potential Improvements:**

**Performance Optimizations:**
- Cache scores for tasks that haven't changed
- Implement incremental scoring for large task lists
- Add early termination for sorting when only top N needed

**Functionality Enhancements:**
- Make scoring weights configurable
- Add more granular time ranges (3-5 days, 2-4 weeks)
- Consider workload distribution (too many tasks due same day)
- Add project/team context factors

**Code Quality Improvements:**
- Extract magic numbers into named constants
- Add type hints for better IDE support
- Implement input validation with descriptive error messages
- Add unit tests for edge cases

**Maintainability Improvements:**
- Separate scoring factors into individual functions
- Add logging for debugging scoring decisions
- Create scoring configuration class
- Add documentation for weight calibration decisions

---

## **Documentation Review and Comparison**

### **Prompt 1 Strengths:**
- ✅ Comprehensive parameter and return value documentation
- ✅ Clear example usage
- ✅ Exception handling information
- ✅ Performance characteristics noted
- ✅ Follows Python docstring conventions perfectly

### **Prompt 2 Strengths:**
- ✅ Explains the "why" behind the algorithm
- ✅ Step-by-step logic breakdown
- ✅ Identifies assumptions and edge cases
- ✅ Suggests practical improvements
- ✅ Provides context for business decisions

### **Best Elements to Combine:**

1. **From Prompt 1**: Formal docstring structure, parameter types, examples
2. **From Prompt 2**: Business logic explanation, step-by-step breakdown, improvement suggestions
3. **Both**: Clear descriptions of edge cases and assumptions

---

## **Final Combined Documentation**

```python
def calculate_task_score(task):
    """
    Calculate a priority score for a task based on multiple weighted factors.
    
    This function implements a compensatory scoring model that evaluates tasks
    based on five key factors: inherent priority level, time sensitivity, work 
    status, special circumstances, and recent activity. The algorithm is designed
    to reflect real-world task management where multiple factors influence 
    importance.
    
    The scoring follows this logic:
    1. Base priority establishes fundamental importance (10-60 points)
    2. Time-based urgency adds or subtracts based on due date proximity (0-35 points)
    3. Work status penalties reduce priority for completed/in-progress tasks (0-50 points)
    4. Special tags provide overrides for critical circumstances (0-8 points)
    5. Recent updates encourage active task management (0-5 points)
    
    Args:
        task (Task): A task object with the following required attributes:
            - priority (TaskPriority): Priority level (LOW, MEDIUM, HIGH, URGENT)
            - due_date (datetime, optional): Due date, None if no due date set
            - status (TaskStatus): Current status (TODO, IN_PROGRESS, REVIEW, DONE)
            - tags (list[str]): String tags for categorization and special handling
            - updated_at (datetime): Timestamp of last task modification
    
    Returns:
        int: Composite priority score. Higher values indicate higher priority.
             Range typically -40 to 103 points. Can be negative for completed tasks.
    
    Raises:
        AttributeError: If task object lacks required attributes
        TypeError: If task attributes have unexpected types
    
    Example:
        >>> from datetime import datetime, timedelta
        >>> task = Task("Critical bug fix", priority=TaskPriority.URGENT)
        >>> task.due_date = datetime.now() - timedelta(days=1)  # Overdue
        >>> task.status = TaskStatus.TODO
        >>> task.tags = ["blocker", "production"]
        >>> task.updated_at = datetime.now()
        >>> score = calculate_task_score(task)
        >>> print(f"Priority score: {score}")  # Expected: 103 (60+35+8+5)
    
    Notes:
        Business Logic Decisions:
        - Overdue tasks (35 points) prioritized over tasks due today (20 points)
        - Completed tasks get -50 points, effectively removing them from priority lists
        - Non-linear priority weights (1,2,4,6) create meaningful gaps between levels
        - Special tags ("blocker", "critical", "urgent") provide 8-point override
        
        Edge Cases:
        - Tasks without due dates receive no time-based scoring
        - Unknown priority levels default to 0 points
        - Recently updated tasks (within 24 hours) get 5-point boost
        - Scores can be negative but sorting handles correctly
        
        Performance:
        - O(1) time complexity per task
        - No external dependencies beyond standard library
    """
    # Base priority weights - non-linear progression creates meaningful gaps
    priority_weights = {
        TaskPriority.LOW: 1,    # Baseline importance
        TaskPriority.MEDIUM: 2,  # 2x low priority
        TaskPriority.HIGH: 4,    # 4x low priority, 2x medium
        TaskPriority.URGENT: 6   # 6x low priority, 1.5x high
    }

    # Calculate base score from priority (multiplied by 10 for range)
    score = priority_weights.get(task.priority, 0) * 10

    # Time-based urgency: overdue > due today > due soon > due later
    if task.due_date:
        days_until_due = (task.due_date - datetime.now()).days
        if days_until_due < 0:  # Overdue tasks get highest urgency bonus
            score += 35
        elif days_until_due == 0:  # Due today - immediate attention needed
            score += 20
        elif days_until_due <= 2:  # Due this week - plan soon
            score += 15
        elif days_until_due <= 7:  # Due next week - upcoming priority
            score += 10

    # Status-based filtering: remove completed, reduce in-progress
    if task.status == TaskStatus.DONE:
        score -= 50  # Effectively removes from priority consideration
    elif task.status == TaskStatus.REVIEW:
        score -= 15  # Reduces priority but keeps visible

    # Special circumstances override normal priority calculations
    if any(tag in ["blocker", "critical", "urgent"] for tag in task.tags):
        score += 8

    # Activity maintenance: encourage recent task management
    days_since_update = (datetime.now() - task.updated_at).days
    if days_since_update < 1:  # Updated within last 24 hours
        score += 5

    return score
```

---

## **Exercise Reflection**

### **What was most challenging for the AI?**

**1. Business Logic Context**: The AI struggled to understand why specific weight values were chosen (35 vs 30 for overdue, 8 points for special tags) without business context.

**2. Edge Case Interactions**: Understanding how multiple factors interact in complex scenarios (overdue + completed + special tags) required additional clarification.

**3. Performance Implications**: The AI needed guidance to understand the performance characteristics and optimization considerations.

### **What additional information was needed in prompts?**

**1. Business Context**: Had to explain that this was for a task management system where overdue work is more urgent than current work.

**2. Expected Usage Patterns**: Needed to describe typical use cases (dashboards, notifications, task lists) to guide documentation focus.

**3. Error Handling Requirements**: Had to specify what types of validation and error handling were expected.

### **How would I use this approach in my own projects?**

**1. Documentation-First Development**: Use these prompts during development to ensure comprehensive documentation from the start.

**2. Code Review Enhancement**: Apply Prompt 2 during code reviews to ensure intent and logic are clear.

**3. Legacy Code Documentation**: Use this approach to document existing undocumented code, starting with Prompt 2 for understanding then Prompt 1 for formal docs.

**4. Team Collaboration**: Share generated documentation with team members to validate understanding and catch missing context.

**5. Documentation Maintenance**: Re-run prompts when code changes to keep documentation synchronized.

---

## **Submission Summary**

### **✅ Original Code:**
Task Priority Sorting Algorithm with three functions

### **✅ Prompt 1 Documentation:**
Comprehensive Python docstrings following conventions with parameters, returns, examples, and notes

### **✅ Prompt 2 Insights:**
Business logic explanation, step-by-step breakdown, assumptions, edge cases, and improvement suggestions

### **✅ Final Combined Documentation:**
Merged the best elements from both approaches - formal structure plus business context and logic explanation

### **✅ Learning Reflection:**
Identified challenges, additional information needs, and practical applications for future projects

This exercise demonstrated how AI prompts can transform code documentation from a mechanical task to a comprehensive explanation of both what the code does and why it works that way.
